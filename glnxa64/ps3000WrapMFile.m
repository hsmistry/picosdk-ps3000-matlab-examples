function [methodinfo,structs,enuminfo,ThunkLibName]=ps3000WrapMFile
%PS3000WRAPMFILE Create structures to define interfaces found in 'ps3000Wrap'.

%This function was generated by loadlibrary.m parser version  on Mon Jan 11 15:27:41 2016
%perl options:'ps3000Wrap.i -outfile=ps3000WrapMFile.m -thunkfile=ps3000Wrap_thunk_glnxa64.c -header=ps3000Wrap.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'ps3000Wrap_thunk_glnxa64');
% extern int16_t GetStreamingLastValues ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='GetStreamingLastValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% extern int16_t IsReady ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='IsReady'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% extern int16_t AvailableData ( int16_t handle , int16_t * overflow , uint32_t * triggeredAt , int16_t * triggered , int16_t * auto_stop , uint32_t * nValues ); 
fcns.thunkname{fcnNum}='int16int16voidPtrvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='AvailableData'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'uint32Ptr', 'int16Ptr', 'int16Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% extern int16_t ClearTriggerInfo ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='ClearTriggerInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% extern int16_t SetDataBuffer ( int16_t handle , int16_t channel , int16_t * buffer , uint32_t bufferLength ); 
fcns.thunkname{fcnNum}='int16int16int16voidPtruint32Thunk';fcns.name{fcnNum}='SetDataBuffer'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% extern void SetDataBuffers ( int16_t handle , int16_t channel , int16_t * minBuffer , int16_t * maxBuffer ); 
fcns.thunkname{fcnNum}='voidint16int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='SetDataBuffers'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int16', 'int16', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% extern int16_t SetDataBuffersV2 ( int16_t handle , int16_t channel , int16_t * minBuffer , int16_t * maxBuffer , uint32_t bufferLength ); 
fcns.thunkname{fcnNum}='int16int16int16voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='SetDataBuffersV2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int16Ptr', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% extern int16_t setChannelCount ( int16_t handle , int16_t channelCount ); 
fcns.thunkname{fcnNum}='int16int16int16Thunk';fcns.name{fcnNum}='setChannelCount'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% extern int16_t setEnabledChannels ( int16_t handle , int16_t * enabledChannels ); 
fcns.thunkname{fcnNum}='int16int16voidPtrThunk';fcns.name{fcnNum}='setEnabledChannels'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% extern int16_t clearFastStreamingParameters ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='clearFastStreamingParameters'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
enuminfo.enBOOL=struct('FALSE',0,'TRUE',1);
methodinfo=fcns;